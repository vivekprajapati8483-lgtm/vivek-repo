"""
create_ec2.py

What it does:
 - ensures a key pair exists (or creates one and saves .pem)
 - ensures a security group exists with SSH (22) and HTTP (80) open
 - launches an EC2 instance with given AMI and instance type
 - waits until instance is running and prints public IP

Configure the CONFIG block below before running.
"""

import boto3
import botocore
import time
from pathlib import Path

# ----------------- CONFIG -----------------
REGION = "us-east-1"                # change to your AWS region
AMI_ID = "ami-0c02fb55956c7d316"    # Amazon Linux 2 (example). Replace with region-appropriate AMI.
INSTANCE_TYPE = "t3.micro"          # free-tier eligible if eligible
KEY_NAME = "my-auto-key"            # keypair name to create/use
KEY_SAVE_PATH = Path.home() / f"{KEY_NAME}.pem"
SECURITY_GROUP_NAME = "auto-ec2-sg"
SECURITY_GROUP_DESC = "Auto-created SG: allow SSH & HTTP"
TAG_NAME = "AutoEC2Instance"
SUBNET_ID = None                    # optional: restrict to a subnet id, else default subnet used
USER_DATA = """#!/bin/bash
# simple user-data: update & install nginx
yum update -y
yum install -y nginx
systemctl enable nginx
systemctl start nginx
echo "<h1>Auto-created EC2 instance</h1>" > /usr/share/nginx/html/index.html
"""
# ------------------------------------------

ec2 = boto3.resource("ec2", region_name=REGION)
ec2_client = boto3.client("ec2", region_name=REGION)

def ensure_key_pair(key_name: str, save_path: Path):
    # If key exists in region, just use it (do NOT be able to fetch private key).
    # If not exists, create and save private key locally.
    try:
        existing = ec2_client.describe_key_pairs(KeyNames=[key_name])
        print(f"[KeyPair] Found existing KeyPair '{key_name}' in region {REGION}.")
        if save_path.exists():
            print(f"[KeyPair] Local key file already present at {save_path}.")
        else:
            print(f"[KeyPair] Private key not present locally. You must have the .pem from creation time.")
        return
    except botocore.exceptions.ClientError as e:
        code = e.response.get("Error", {}).get("Code", "")
        if code == "InvalidKeyPair.NotFound":
            # create keypair
            print(f"[KeyPair] Creating KeyPair '{key_name}' ...")
            resp = ec2_client.create_key_pair(KeyName=key_name)
            private_key = resp["KeyMaterial"]
            save_path.write_text(private_key)
            save_path.chmod(0o400)
            print(f"[KeyPair] Saved private key to {save_path} (chmod 400).")
            return
        else:
            raise

def ensure_security_group(name: str, description: str):
    # Check by name tag (group name). If exists, return security_group_id
    try:
        resp = ec2_client.describe_security_groups(Filters=[{"Name":"group-name","Values":[name]}])
        groups = resp.get("SecurityGroups", [])
        if groups:
            sg_id = groups[0]["GroupId"]
            print(f"[SG] Found existing security group '{name}' -> {sg_id}")
            return sg_id
    except botocore.exceptions.ClientError as e:
        # fall through to create
        pass

    # create new SG in default VPC
    print(f"[SG] Creating security group '{name}' ...")
    vpcs = ec2_client.describe_vpcs()["Vpcs"]
    if not vpcs:
        raise SystemExit("No VPCs found in account/region.")
    default_vpc = next((v for v in vpcs if v.get("IsDefault")), vpcs[0])
    vpc_id = default_vpc["VpcId"]

    resp = ec2_client.create_security_group(
        GroupName=name,
        Description=description,
        VpcId=vpc_id
    )
    sg_id = resp["GroupId"]
    print(f"[SG] Created {sg_id} in VPC {vpc_id}. Authorizing ingress ...")

    # open SSH (22), HTTP (80) - modify as needed
    ec2_client.authorize_security_group_ingress(
        GroupId=sg_id,
        IpPermissions=[
            {"IpProtocol": "tcp", "FromPort": 22, "ToPort": 22,
             "IpRanges": [{"CidrIp": "0.0.0.0/0", "Description":"SSH access (open) - secure as needed"}]},
            {"IpProtocol": "tcp", "FromPort": 80, "ToPort": 80,
             "IpRanges": [{"CidrIp": "0.0.0.0/0", "Description":"HTTP"}]},
        ],
    )
    print(f"[SG] Ingress rules set for SSH and HTTP.")
    return sg_id

def launch_instance(ami_id, instance_type, key_name, security_group_id, subnet_id=None, user_data_script=None, tag_name=None):
    params = dict(
        ImageId=ami_id,
        InstanceType=instance_type,
        KeyName=key_name,
        MaxCount=1,
        MinCount=1,
        SecurityGroupIds=[security_group_id],
        UserData=user_data_script,
    )
    if subnet_id:
        params["SubnetId"] = subnet_id

    print(f"[EC2] Launching instance with AMI={ami_id}, Type={instance_type} ...")
    instances = ec2.create_instances(**params)
    instance = instances[0]
    print(f"[EC2] Launched instance {instance.id}. Waiting for running state...")
    instance.wait_until_running()
    instance.reload()
    # add tag
    if tag_name:
        instance.create_tags(Tags=[{"Key":"Name","Value":tag_name}])
    public_ip = instance.public_ip_address
    print(f"[EC2] Instance {instance.id} is running. Public IP: {public_ip}")
    return instance

def main():
    try:
        ensure_key_pair(KEY_NAME, KEY_SAVE_PATH)
        sg_id = ensure_security_group(SECURITY_GROUP_NAME, SECURITY_GROUP_DESC)
        inst = launch_instance(AMI_ID, INSTANCE_TYPE, KEY_NAME, sg_id, SUBNET_ID, USER_DATA, TAG_NAME)
        print("\n==== Instance details ====")
        print("InstanceId:", inst.id)
        print("PublicIp:", inst.public_ip_address)
        print("PublicDns:", inst.public_dns_name)
        print("KeyPath:", KEY_SAVE_PATH)
        print("==========================")
        print("You can SSH: ssh -i", KEY_SAVE_PATH, f"ec2-user@{inst.public_ip_address}")
    except Exception as e:
        print("Error:", str(e))
        raise

if __name__ == "__main__":
    main()

